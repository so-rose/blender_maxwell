# blender_maxwell
# Copyright (C) 2024 blender_maxwell Project Contributors
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import enum
import functools
import typing as typ

from blender_maxwell.contracts import BLEnumElement
from blender_maxwell.utils import logger
from blender_maxwell.utils import sympy_extra as spux
from blender_maxwell.utils.staticproperty import staticproperty

log = logger.get(__name__)

_PROPERTY_NAMES = {
	'capabilities',
	'previews',
	'value',
	'array',
	'lazy_range',
	'lazy_func',
	'params',
	'info',
}


class FlowKind(enum.StrEnum):
	"""Defines a kind of data that can flow between nodes.

	Each node link can be thought to contain **multiple pipelines for data to flow along**.
	Each pipeline is cached incrementally, and independently, of the others.
	Thus, the same socket can easily support several kinds of related data flow at the same time.

	Attributes:
		Capabilities: Describes a socket's linkeability with other sockets.
			Links between sockets with incompatible capabilities will be rejected.
			This doesn't need to be defined normally, as there is a default.
			However, in some cases, defining it manually to control linkeability more granularly may be desirable.
		Value: A generic object, which is "directly usable".
			This should be chosen when a more specific flow kind doesn't apply.
		Array: An object with dimensions, and possibly a unit.
			Whenever a `Value` is defined, a single-element `list` will also be generated by default as `Array`
			However, for any other array-like variants (or sockets that only represent array-like objects), `Array` should be defined manually.
		Func: A composable function.
			Can be used to represent computations for which all data is not yet known, or for which just-in-time compilation can drastically increase performance.
		Range: An object that generates an `Array` from range information (start/stop/step/spacing).
			This should be used instead of `Array` whenever possible.
		Param: A dictionary providing particular parameters for a lazy value.
		Info: An dictionary providing extra context about any aspect of flow.
	"""

	Capabilities = enum.auto()
	Previews = enum.auto()

	# Values
	Value = enum.auto()  ## 'value'
	Array = enum.auto()  ## 'array'

	# Lazy
	Range = enum.auto()  ## 'lazy_range'
	Func = enum.auto()  ## 'lazy_func'

	# Auxiliary
	Params = enum.auto()  ## 'params'
	Info = enum.auto()  ## 'info'

	####################
	# - UI
	####################
	@staticmethod
	def to_name(v: typ.Self) -> str:
		return {
			FlowKind.Capabilities: 'Capabilities',
			FlowKind.Previews: 'Previews',
			# Values
			FlowKind.Value: 'Value',
			FlowKind.Array: 'Array',
			# Lazy
			FlowKind.Func: 'Func',
			FlowKind.Range: 'Range',
			# Auxiliary
			FlowKind.Params: 'Params',
			FlowKind.Info: 'Info',
		}[v]

	@staticmethod
	def to_icon(_: typ.Self) -> str:
		return ''

	@property
	def name(self) -> str:
		return FlowKind.to_name(self)

	@property
	def icon(self) -> str:
		return FlowKind.to_icon(self)

	def bl_enum_element(self, i) -> BLEnumElement:
		return (str(self), self.name, self.name, self.icon, i)

	####################
	# - Static Properties
	####################
	@staticproperty
	def property_names() -> set[str]:
		"""Set of strings for (socket) properties associated with a `FlowKind`.

		Usable for optimized O(1) lookup, to check whether a property name can be converted to a `FlowKind`.
		To actually retrieve the `FlowKind` from one of these names, use `FlowKind.from_property_name()`.
		"""
		return _PROPERTY_NAMES

	@functools.cache
	@staticmethod
	def from_property_name(prop_name: str) -> typ.Self:
		"""Retrieve the `FlowKind` associated with a particular property name.

		Parameters:
			prop_name: The name of the property.
				**Must** be a string defined in `FlowKind.property_names`.
		"""
		return {
			'capabilities': FlowKind.Capabilities,
			'previews': FlowKind.Previews,
			'value': FlowKind.Value,
			'array': FlowKind.Array,
			'lazy_range': FlowKind.Range,
			'lazy_func': FlowKind.Func,
			'params': FlowKind.Params,
			'info': FlowKind.Info,
		}[prop_name]

	@functools.cached_property
	def property_name(self) -> typ.Self:
		"""Retrieve the `FlowKind` associated with a particular property name.

		Parameters:
			prop_name: The name of the property.
				**Must** be a string defined in `FlowKind.property_names`.
		"""
		return {
			FlowKind.from_property_name(prop_name): prop_name
			for prop_name in FlowKind.property_names
		}[self]

	@staticproperty
	def active_kinds() -> list[typ.Self]:
		"""Return a list of `FlowKind`s that are able to be considered "active".

		"Active" `FlowKind`s are considered the primary data type of a socket's flow.
		For example, for sockets to be linkeable, their active `FlowKind` must generally match.
		"""
		return [
			FlowKind.Value,
			FlowKind.Array,
			FlowKind.Range,
			FlowKind.Func,
		]

	@property
	def socket_shape(self) -> str:
		"""Return the socket shape associated with this `FlowKind`.

		Should generally only be used with `active_kinds`.

		Raises:
			ValueError: If this `FlowKind` cannot ever be considered "active".
		"""
		return {
			FlowKind.Value: 'CIRCLE',
			FlowKind.Array: 'SQUARE',
			FlowKind.Range: 'SQUARE',
			FlowKind.Func: 'DIAMOND',
		}.get(self, 'CIRCLE')

	####################
	# - Class Methods
	####################
	def scale_to_unit_system(
		self,
		flow: typ.Any,
		unit_system: spux.UnitSystem,
		use_jax_array: bool = True,
	):
		"""Perform unit-system scaling per-`FlowKind`."""
		match self:
			case FlowKind.Value if isinstance(spux.SympyType):
				return spux.scale_to_unit_system(
					flow,
					unit_system,
					use_jax_array=use_jax_array,
				)

			case FlowKind.Array | FlowKind.Range:
				return flow.rescale_to_unit_system(unit_system)

			case FlowKind.Func:
				return flow.scale_to_unit_system(unit_system)

			case FlowKind.Params:
				return flow

			case FlowKind.Info:
				return flow.scale_to_unit_system(unit_system)

		msg = f"Applying unit-system scaling to {self} doesn't make sense"
		raise ValueError(msg)
